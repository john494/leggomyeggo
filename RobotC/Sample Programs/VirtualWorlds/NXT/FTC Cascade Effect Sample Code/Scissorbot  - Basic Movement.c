#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          wristMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     frontRightMotor, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     frontLeftMotor, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rearRightMotor, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rearLeftMotor, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     rightScissor,  tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     leftScissor,   tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
This program is designed to give new programmers beginning code that allows their robots to move from
point to point on the gameboard. The program uses three functions: moveForward, turnRight, and turnLeft
to move around the gameboard.  Each of the functions accepts two paramenters: encoderCounts and speed.

Scissorbot - Basic Movement
- This program demonstrates basic movements (forward, turn left, turn right) that can be performed
with the Scissorbot using encoder-based programming.

Robot Model(s): TETRIX Scissorbot (Virtual Worlds)
[I/O Port]          [Name]              [Type]                [Description]
Motor Port A 				gripperMotor				NXT Motor 						NXT Gripper Motor
Motor Port B				wristMotor					NXT Motor 						NXT Wrist Motor
Motor Port D        frontRightMotor     TETRIX Motor          Front Right side motor
Motor Port E				frontLeftMotor			TETRIX Motor					Front Left side motor
Motor Port F        rearRightMotor      TETRIX Motor          Rear Right side motor
Motor Port G				rearLeftMotor				TETRIX Motor					Rear Left side motor
Motor Port H 				rightScissorMotor		TETRIX Motor					Right Scissor Lift motor
Motor Port I 				leftScissorMotor		TETRIX Motor 					Left Scissor Lift motor

Sensor Port 2				gyro						    Gyroscope							Gyroscopic Sensor
Sensor Port 3				lightSensor  				Light Sensor					NXT Light Sensor (Active)
Sensor Port 4				sonarSensor 				Sonar Sensor					NXT Sonar Sensor
----------------------------------------------------------------------------------------------------*/

//Function to move the robot forward for a specified amount of encoder counts
//at a specified speed
void moveForward(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder(rearRightMotor) = 0;
	nMotorEncoder(rearLeftMotor)  = 0;

	//While both of the encoders are less than the specified amount
	while(nMotorEncoder(rearRightMotor) < encoderCounts && nMotorEncoder(rearLeftMotor) < encoderCounts)
	{
		//If both of the encoder values are equal
		if (nMotorEncoder(rearRightMotor) == nMotorEncoder(rearLeftMotor))
		{
			//Move the robot forward at the specified speed
			motor[rearRightMotor]  = speed;
			motor[rearLeftMotor]   = speed;
			motor[frontRightMotor] = speed;
			motor[frontLeftMotor]  = speed;
		}

		//If the right encoder is greater than the left encoder (veering left)
		else if (nMotorEncoder(rearRightMotor) > nMotorEncoder(rearLeftMotor))
		{
			//Adjust the robot to the right
			motor[rearRightMotor]  = speed;
			motor[rearLeftMotor]   = speed+5;
			motor[frontRightMotor] = speed;
			motor[frontLeftMotor]  = speed+5;
		}

		//If the left encoder is greater than the right encoder (veering right)
		else if (nMotorEncoder(rearRightMotor) < nMotorEncoder(rearLeftMotor))
		{
			//Adjust the robot to the left
			motor[rearRightMotor]  = speed+5;
			motor[rearLeftMotor]   = speed;
			motor[frontRightMotor] = speed+5;
			motor[frontLeftMotor]  = speed;
		}
	}

	//Stop the robot
	motor[rearRightMotor]  = 0;
	motor[rearLeftMotor]   = 0;
	motor[frontRightMotor] = 0;
	motor[frontLeftMotor]  = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnLeft(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	nMotorEncoder(rearRightMotor) = 0;
	nMotorEncoder(rearLeftMotor)  = 0;

	//While the absolute value of the right motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder(rearRightMotor)) < encoderCounts)
	{
		//Turn the robot to the left at the specified speed
		motor[rearRightMotor]  = speed;
		motor[rearLeftMotor]   = -speed;
		motor[frontRightMotor] = speed;
		motor[frontLeftMotor]  = -speed;
	}

	//Stop the robot
	motor[rearRightMotor]  = 0;
	motor[rearLeftMotor]   = 0;
	motor[frontRightMotor] = 0;
	motor[frontLeftMotor]  = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnRight(int encoderCounts, int speed)
{
	//Clear the encoders
	nMotorEncoder(rearRightMotor) = 0;
	nMotorEncoder(rearLeftMotor)  = 0;

	//While the absolute value of the left motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder(rearLeftMotor)) < encoderCounts)
	{
		//Turn the robot to the right at the specified speed
		motor[rearRightMotor]  = -speed;
		motor[rearLeftMotor]   = speed;
		motor[frontRightMotor] = -speed;
		motor[frontLeftMotor]  = speed;
	}

	//Stop the robot
	motor[rearRightMotor]  = 0;
	motor[rearLeftMotor]   = 0;
	motor[frontRightMotor] = 0;
	motor[frontLeftMotor]  = 0;
}

task main()
{
	//Move the robot forward for 1000 encoder counts
	//at a speed of 50, then wait for half of a second
	moveForward(1000, 50);
	wait1Msec(500);

	//Turn the robot to the right for 2340 encoder counts
	//at a speed of 25, then wait for half of a second
	turnRight(2340, 25);
	wait1Msec(500);

	//Turn the robot to the left for 2340 encoder counts
	//at a speed of 25, then wait for half of a second
	turnLeft(2340, 25);
	wait1Msec(500);
}
