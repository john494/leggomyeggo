#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int lightValue;
int darkValue;
int sumValue;
int thresholdValue;
int countValue = 0;
int lastSeen;

void findThreshold()
{

	while(SensorValue(touchSensor) == 0)
	{
		displayStringAt(0,31,"Read Light Now");
	}

	lightValue = SensorValue(lightSensor);

	wait1Msec(1000);

	while(SensorValue(touchSensor) == 0)
	{
		displayStringAt(0,31,"Read Dark Now");
	}

	darkValue = SensorValue(lightSensor);

	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;

}

void forward4Lines()
{

	lastSeen = 1;
	countValue = 0;

	while(countValue < 4)
	{

		motor[motorC] = 50;
		motor[motorB] = 50;

		if(SensorValue(lightSensor) < thresholdValue)
		{

			if(lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}

		}

		else
		{
			lastSeen = 1;
		}

	}

}

void forward3Lines()
{

	lastSeen = 1;
	countValue = 0;

	while(countValue < 3)
	{

		motor[motorC] = 50;
		motor[motorB] = 50;

		if(SensorValue(lightSensor) < thresholdValue)
		{

			if(lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}

		}

		else
		{
			lastSeen = 1;
		}

	}

}void forward2Lines()
{

	lastSeen = 1;
	countValue = 0;

	while(countValue < 2)
	{

		motor[motorC] = 50;
		motor[motorB] = 50;

		if(SensorValue(lightSensor) < thresholdValue)
		{

			if(lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}

		}

		else
		{
			lastSeen = 1;
		}

	}

}

void turnLeft()
{
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] > -100)
	{
		motor[motorC] = -50;
		motor[motorB] = -50;
	}

	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 160)
	{
		motor[motorC] = -50;
		motor[motorB] = 50;
	}

	motor[motorC] = 0;
	motor[motorB] = 0;

}

void turnRight()
{
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] > -100)
	{
		motor[motorC] = -50;
		motor[motorB] = -50;
	}

	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < 160)
	{
		motor[motorC] = 50;
		motor[motorB] = -50;
	}

	motor[motorC] = 0;
	motor[motorB] = 0;

}


task main()
{



	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

	findThreshold();
	forward4Lines();
	turnLeft();
	forward3Lines();
	turnRight();
	forward2Lines();

}
