#pragma config(Sensor, S4,     sonar,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                       "Try Me" Program for NXT SONAR Sensor - Enhanced
//
// The enhancement from the standard NXT Sonar "Try Me" is that there's a graphical display
// of the Sonar Sensor readings. This is useful for looking at the normal variation in the
// Sonar readings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma fileExtension("rtm")
#pragma platform("NXT")

//
// Special "distance" values returned by the SONAR device driver to indicate error conditions
//
typedef enum TSonarErrorCodes
{
	sonarNoSensorConnected = 254,
	sonarOutOfRange        = 255
} TSonarErrorCodes;

//
// Count the number of "out of range" errors encountered
//
int nRangeErrors;
int nDisconnects;
int nSonarDistance;



//
// Standard 'C' does not support scalar 'const' declarations. ROBOTC does. It's nicer than using
//     "#define kGraphWidth 100"
//
const int kGraphWidth = 100;
const int kGraphBottom =  0;
const int kGraphHeight = 40;
const int kGraphTop    = kGraphBottom + kGraphHeight - 1;
//
// Note variables can be initialized in the declaration statement with the use of an optional
// "= <epxression>" clause after the declaration.
//
int nMaxGraphPoint = kGraphHeight;
int nGraphDivisor = 1;
int nHistogram[kGraphWidth];


//
// ROBOTC supports
//
void initializeGraph();
void addDataPoint(int nColumn);

task main()
{
	nRangeErrors = 0;
	nDisconnects = 0;
	nSonarDistance = 0;
	nVolume = 2;

	//
	// Grab LCD screen and initialize display
	//
	initializeGraph();
	eraseDisplay();
	displayTextLine(0, "SONAR on port 4");

	while (true)
	{
		//
		// Wait for sonar Sensor to be connected
		//
		while (SensorRaw[sonar] == (int) sonarNoSensorConnected)
		{
			alive();
			displayTextLine(1, "Not connected");
			playSound(soundShortBlip);
			while(bSoundActive)
			{}
			wait1Msec(25);
		}
		//
		// Update the LCD screen to show connected
		//
		displayTextLine(1, "Connected");
		displayTextLine(2, "Stabilizing");
		//
		// Let SONAR sensor stabilize
		//
		wait1Msec(500);
		displayTextLine(2, "");
		//
		// Repeat until sensor is disconnected
		//
		while (true)
		{
			alive();
			if (SensorRaw[sonar] == (short) sonarNoSensorConnected)
				break;

			if (SensorRaw[sonar] == (short)  sonarOutOfRange)
			{
				playTone( 750, 5);
				playTone(1500, 5);
				++nRangeErrors;
			}
			else
			{
				int nFrequency;
				const int kMinFrequency = 220; // Lowest frequency the NXT will play
				const int kMultiplier   = 8;

				nSonarDistance = SensorValue[sonar];
				nFrequency = kMinFrequency + nSonarDistance * kMultiplier;
				playImmediateTone(nFrequency, 10);
				addDataPoint(nSonarDistance);
			}
			if (nRangeErrors == 0)
			{
				displayTextLine(1, "Value ");
				displayTextLine(2,  "%5d", nSonarDistance);
			}
			else if (nDisconnects == 0)
			{
				displayTextLine(1, "Value Range ");
				displayTextLine(2,   "%5d %5d ", nSonarDistance, nRangeErrors);
			}
			else
			{
				//displayTextLine(1, "Value Range Disc");
				//displayTextLine(2,   "%5d %5d %4d", nSonarDistance, nRangeErrors, nDisconnects);
				displayTextLine(1, "Value Range ");
				displayTextLine(2,   "%5d %5d ", nSonarDistance, nRangeErrors);
			}
			wait1Msec(90);
		}
		++nDisconnects;
		//displayTextLine(1, "Value Range Disc");
		//displayTextLine(2,  "%5d %5d %4d", nSonarDistance, nRangeErrors, nDisconnects);
		displayTextLine(1, "Value Range ");
		displayTextLine(2,   "%5d %5d ", nSonarDistance, nRangeErrors);
	}
}


void initializeGraph()
{
	//
	// Zero out the histogram entries
	//
	int i;
	for (i = 0; i < kGraphWidth; ++i)
		nHistogram[i] = 0;
	return;
}


void rescaleHistogram(int nCurrentMaximumValue)
{
	int i;

	eraseRect(0, kGraphBottom, kGraphWidth - 1, kGraphTop);
	nCurrentMaximumValue += kGraphHeight;
	nGraphDivisor = (nCurrentMaximumValue + (kGraphHeight - 1)) / kGraphHeight;
	nMaxGraphPoint = nGraphDivisor * kGraphHeight;
	for (i = 0; i < kGraphWidth; ++ i)
	{
		if (nHistogram[i] != 0)
		  drawLine(i, kGraphBottom, i, kGraphBottom + (nHistogram[i] / nGraphDivisor));
	}
	return;
}

void addDataPoint(int nColumn)
{
	int nNewValue;

	if (nColumn > (kGraphWidth - 1))
		nColumn = kGraphWidth - 1;

	++nHistogram[nColumn];
	nNewValue = nHistogram[nColumn];
	if (nNewValue < nMaxGraphPoint)
		setPixel(nColumn, kGraphBottom + (nNewValue / nGraphDivisor));
	else if (nNewValue > nMaxGraphPoint)
		rescaleHistogram(nNewValue);
	return;
}
